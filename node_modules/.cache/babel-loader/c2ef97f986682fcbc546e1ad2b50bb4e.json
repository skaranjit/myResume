{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar IsInteger = require('./IsInteger');\n\nvar Type = require('./Type');\n\nvar MAX_SAFE_INTEGER = require('../helpers/maxSafeInteger');\n\nvar isLeadingSurrogate = require('../helpers/isLeadingSurrogate');\n\nvar isTrailingSurrogate = require('../helpers/isTrailingSurrogate');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar $charCodeAt = require('call-bind/callBound')('String.prototype.charCodeAt'); // https://ecma-international.org/ecma-262/6.0/#sec-advancestringindex\n\n\nmodule.exports = function AdvanceStringIndex(S, index, unicode) {\n  if (Type(S) !== 'String') {\n    throw new $TypeError('Assertion failed: `S` must be a String');\n  }\n\n  if (!IsInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {\n    throw new $TypeError('Assertion failed: `length` must be an integer >= 0 and <= 2**53');\n  }\n\n  if (Type(unicode) !== 'Boolean') {\n    throw new $TypeError('Assertion failed: `unicode` must be a Boolean');\n  }\n\n  if (!unicode) {\n    return index + 1;\n  }\n\n  var length = S.length;\n\n  if (index + 1 >= length) {\n    return index + 1;\n  }\n\n  var first = $charCodeAt(S, index);\n\n  if (!isLeadingSurrogate(first)) {\n    return index + 1;\n  }\n\n  var second = $charCodeAt(S, index + 1);\n\n  if (!isTrailingSurrogate(second)) {\n    return index + 1;\n  }\n\n  return index + 2;\n};","map":{"version":3,"sources":["/Users/sumankaranjit/myProfile/resume/node_modules/es-abstract/2018/AdvanceStringIndex.js"],"names":["GetIntrinsic","require","IsInteger","Type","MAX_SAFE_INTEGER","isLeadingSurrogate","isTrailingSurrogate","$TypeError","$charCodeAt","module","exports","AdvanceStringIndex","S","index","unicode","length","first","second"],"mappings":"AAAA;;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,eAAD,CAA1B;;AAEA,IAAIC,SAAS,GAAGD,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIE,IAAI,GAAGF,OAAO,CAAC,QAAD,CAAlB;;AAEA,IAAIG,gBAAgB,GAAGH,OAAO,CAAC,2BAAD,CAA9B;;AACA,IAAII,kBAAkB,GAAGJ,OAAO,CAAC,+BAAD,CAAhC;;AACA,IAAIK,mBAAmB,GAAGL,OAAO,CAAC,gCAAD,CAAjC;;AAEA,IAAIM,UAAU,GAAGP,YAAY,CAAC,aAAD,CAA7B;;AAEA,IAAIQ,WAAW,GAAGP,OAAO,CAAC,qBAAD,CAAP,CAA+B,6BAA/B,CAAlB,C,CAEA;;;AAEAQ,MAAM,CAACC,OAAP,GAAiB,SAASC,kBAAT,CAA4BC,CAA5B,EAA+BC,KAA/B,EAAsCC,OAAtC,EAA+C;AAC/D,MAAIX,IAAI,CAACS,CAAD,CAAJ,KAAY,QAAhB,EAA0B;AACzB,UAAM,IAAIL,UAAJ,CAAe,wCAAf,CAAN;AACA;;AACD,MAAI,CAACL,SAAS,CAACW,KAAD,CAAV,IAAqBA,KAAK,GAAG,CAA7B,IAAkCA,KAAK,GAAGT,gBAA9C,EAAgE;AAC/D,UAAM,IAAIG,UAAJ,CAAe,iEAAf,CAAN;AACA;;AACD,MAAIJ,IAAI,CAACW,OAAD,CAAJ,KAAkB,SAAtB,EAAiC;AAChC,UAAM,IAAIP,UAAJ,CAAe,+CAAf,CAAN;AACA;;AACD,MAAI,CAACO,OAAL,EAAc;AACb,WAAOD,KAAK,GAAG,CAAf;AACA;;AACD,MAAIE,MAAM,GAAGH,CAAC,CAACG,MAAf;;AACA,MAAKF,KAAK,GAAG,CAAT,IAAeE,MAAnB,EAA2B;AAC1B,WAAOF,KAAK,GAAG,CAAf;AACA;;AAED,MAAIG,KAAK,GAAGR,WAAW,CAACI,CAAD,EAAIC,KAAJ,CAAvB;;AACA,MAAI,CAACR,kBAAkB,CAACW,KAAD,CAAvB,EAAgC;AAC/B,WAAOH,KAAK,GAAG,CAAf;AACA;;AAED,MAAII,MAAM,GAAGT,WAAW,CAACI,CAAD,EAAIC,KAAK,GAAG,CAAZ,CAAxB;;AACA,MAAI,CAACP,mBAAmB,CAACW,MAAD,CAAxB,EAAkC;AACjC,WAAOJ,KAAK,GAAG,CAAf;AACA;;AAED,SAAOA,KAAK,GAAG,CAAf;AACA,CA7BD","sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar IsInteger = require('./IsInteger');\nvar Type = require('./Type');\n\nvar MAX_SAFE_INTEGER = require('../helpers/maxSafeInteger');\nvar isLeadingSurrogate = require('../helpers/isLeadingSurrogate');\nvar isTrailingSurrogate = require('../helpers/isTrailingSurrogate');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar $charCodeAt = require('call-bind/callBound')('String.prototype.charCodeAt');\n\n// https://ecma-international.org/ecma-262/6.0/#sec-advancestringindex\n\nmodule.exports = function AdvanceStringIndex(S, index, unicode) {\n\tif (Type(S) !== 'String') {\n\t\tthrow new $TypeError('Assertion failed: `S` must be a String');\n\t}\n\tif (!IsInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {\n\t\tthrow new $TypeError('Assertion failed: `length` must be an integer >= 0 and <= 2**53');\n\t}\n\tif (Type(unicode) !== 'Boolean') {\n\t\tthrow new $TypeError('Assertion failed: `unicode` must be a Boolean');\n\t}\n\tif (!unicode) {\n\t\treturn index + 1;\n\t}\n\tvar length = S.length;\n\tif ((index + 1) >= length) {\n\t\treturn index + 1;\n\t}\n\n\tvar first = $charCodeAt(S, index);\n\tif (!isLeadingSurrogate(first)) {\n\t\treturn index + 1;\n\t}\n\n\tvar second = $charCodeAt(S, index + 1);\n\tif (!isTrailingSurrogate(second)) {\n\t\treturn index + 1;\n\t}\n\n\treturn index + 2;\n};\n"]},"metadata":{},"sourceType":"script"}